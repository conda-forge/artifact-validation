#!/usr/bin/env python
import os
import github
import tempfile
import subprocess
import random
import copy
import requests

import click
import yaml

PKGS_DATA = "scan_data/invalid_packages.yaml"
PKG_PRS_DATA = "scan_data/invalid_packages_prs.yaml"

GH = github.Github(os.environ["GH_TOKEN"])
USER = GH.get_user().login
REPO = GH.get_repo("conda-forge/admin-requests")
REPO.create_fork()

MAX_PRS = 10


def _get_sharded_path(output):
    chars = [c for c in output if c.isalnum()]
    while len(chars) < 3:
        chars.append("z")

    return os.path.join("outputs", chars[0], chars[1], chars[2], output + ".json")


def _get_teams_for_output(output):
    pth = _get_sharded_path(output)
    n_try = 3
    for i in range(n_try):
        try:
            r = requests.get(
                "https://raw.githubusercontent.com/conda-forge/"
                f"feedstock-outputs/master/{pth}"
            )
            r.raise_for_status()
            return r.json()["feedstocks"]
        except Exception:
            if i < n_try-1:
                pass
            else:
                return [output]


def _run_git_cmd(cmd, cwd=None):
    subprocess.run(
        "git " + cmd,
        shell=True,
        check=True,
        cwd=cwd,
    )


def _make_pr(pkg, dists_to_pr, v, tmpdir, dry_run=False, job_url=None):
    cwd = os.path.join(tmpdir, "admin-requests")
    hashval = "%x" % random.getrandbits(32)
    branch_name = "%s-%s" % (pkg, hashval)

    _run_git_cmd("checkout master", cwd=cwd)
    _run_git_cmd("checkout -b '%s'" % branch_name, cwd=cwd)

    with open(os.path.join(cwd, "broken", "%s.txt" % branch_name), "w") as fp:
        for dist in dists_to_pr:
            fp.write(dist + "\n")

    _run_git_cmd("add broken/.", cwd=cwd)
    _run_git_cmd(
        "commit -m 'mark invalid packages for %s as broken'" % pkg,  # noqa
        cwd=cwd,
    )
    _run_git_cmd("status", cwd=cwd)
    _run_git_cmd("push --set-upstream origin %s" % branch_name, cwd=cwd)  # noqa

    dist_info = {
        dist: v[dist]
        for dist in dists_to_pr
    }

    hi_line = " ".join(
        "@conda-forge/%s" % team for team in _get_teams_for_output(pkg)
    )

    body = """\
Hi %s! I am the friendly conda-forge artifact validation bot!

I made this PR because I found files in one or more of your packages that are not allowed \
for that package. Once this PR is merged, the builds listed below will be marked as broken. They will not be installable \
from the main conda-forge channels, but you will still be able to download them from anaconda.org.

The core team will usually wait a week to merge these PRs. However, they may merge them earlier if they \
deem the packages below a signifcant security or usability issue.

If you think this PR was made by mistake or is incorrect, please get in touch with the core team in this PR or on \
[our Element channel](https://app.element.io/#/room/#conda-forge:matrix.org)!

Information on invalid packages (see the files listed under `bad_paths`):

<details>

```
%s
```

</details>
""" % (hi_line, yaml.dump(dist_info, default_flow_style=False),)  # noqa

    title = "mark invalid packages for %s as broken" % pkg

    if job_url is not None:
        body += "\n\nThis job was generated by %s." % job_url

    if not dry_run:
        pr = REPO.create_pull(
            title=title,
            body=body,
            base="master",
            head="%s:%s" % (USER, branch_name),
            maintainer_can_modify=True,
        )

        return {
            "url": pr.html_url,
            "number": pr.number,
            "head_branch": branch_name,
        }
    else:
        print("    PR title:", title, flush=True)
        print("    PR body:\n" + body, flush=True)
        return None


@click.command()
@click.option('--dry-run', is_flag=True, help="do not make any PRs but print info")
@click.option('--job-url', type=str, default=None, help="the URL of the CI job")
def main(dry_run, job_url):
    """Make PRs to mark invalid packages as broken."""
    with open(PKGS_DATA, "r") as fp:
        pkgs = yaml.safe_load(fp)

    if os.path.exists(PKG_PRS_DATA):
        with open(PKG_PRS_DATA, "r") as fp:
            pkg_prs = yaml.safe_load(fp)
    else:
        pkg_prs = {}

    num_prs = 0

    try:
        with tempfile.TemporaryDirectory() as tmpdir:
            _run_git_cmd(
                f"clone https://github.com/{USER}/admin-requests.git",
                cwd=tmpdir,
            )

            _run_git_cmd(
                "remote set-url --push origin https://%s@github.com"
                "/%s/admin-requests.git" % (os.environ["GH_TOKEN"], USER),
                cwd=os.path.join(tmpdir, "admin-requests")
            )

            for pkg, v in pkgs.items():
                print("=" * 80, flush=True)
                print("=" * 80, flush=True)
                print(f"making PRs for {pkg}", flush=True)

                dists_to_pr = []
                for dist in v:
                    print(f"    dist: {dist}", flush=True)
                    if dist in pkg_prs:
                        print(
                            "        already PRed: %s" % pkg_prs[dist]["url"],
                            flush=True,
                        )
                    else:
                        print("        adding to PR list", flush=True)
                        dists_to_pr.append(dist)

                if dists_to_pr:
                    pr_data = _make_pr(
                        pkg, dists_to_pr, v, tmpdir,
                        dry_run=dry_run, job_url=job_url,
                    )

                    if pr_data is not None:
                        num_prs += 1

                    for dist in dists_to_pr:
                        if pr_data is not None:
                            pkg_prs[dist] = copy.deepcopy(pr_data)

                print("\n", flush=True)
                if num_prs >= MAX_PRS:
                    print(
                        "made the maximum number of "
                        "allowed PRS: %d - stopping!" % num_prs,
                        flush=True,
                    )
                    break

    finally:
        for k in pkg_prs:
            pkg_prs[k] = copy.deepcopy(pkg_prs[k])

        with open(PKG_PRS_DATA, "w") as fp:
            yaml.dump(pkg_prs, fp, default_flow_style=False)


if __name__ == "__main__":
    main()
